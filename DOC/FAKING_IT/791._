        //:#_DOWNSCALE_LOOP_#:[791]:---------------------://     // [791]
        for( liy = l0y ; liy <= l1y ; liy ++ ){//:@Y_O_L@://     // [791]
        for( lix = l0x ; lix <= l1x ; lix ++ ){//:@X_I_L@://     // [791]
                                                                 // [791]
            vsp_x_0 =( p_b.pix_x_0 + ( (lix-l0x)*btw ) );        // [791]
            vsp_y_0 =( p_b.pix_y_0 + ( (liy-l0y)*bth ) );        // [791]
            vsp_x_1 =( p_b.pix_x_1 + ( (lix-l0x)*btw ) );        // [791]
            vsp_y_1 =( p_b.pix_y_1 + ( (liy-l0y)*bth ) );        // [791]
                                                                 // [791]
            a_r =( 0 ); //:Erase_Average_RED :::://              // [791]
            a_g =( 0 ); //:Erase_Average_GRE :::://              // [791]
            a_b =( 0 ); //:Erase_Average_BLU :::://              // [791]
            a_a =( 0 ); //:Erase_Average_ALP :::://              // [791]
                                                                 // [791]
            for( vsy = vsp_y_0 ; vsy <=vsp_y_1 ; vsy++ ){        // [791]
            for( vsx = vsp_x_0 ; vsx <=vsp_x_1 ; vsx++ ){        // [791]
                                                                 // [791]
                bix =( vsx ); //: ONE_IN_THE_SAME :::::::://     // [791]
                biy =( vsy ); //: ONE_IN_THE_SAME :::::::://     // [791]
                                                                 // [791]
                bii =( vsx + ( vsy * b_w ) );                    // [791]
                bic =( bii * 4 );;;;;;;;;;;;;                    // [791]
                                                                 // [791]
                a_r +=( p_b[ bic+0 ] );                          // [791]
                a_g +=( p_b[ bic+1 ] );                          // [791]
                a_b +=( p_b[ bic+2 ] );                          // [791]
                a_a +=( p_b[ bic+3 ] );                          // [791]
                                                                 // [791]
            };;};; //:NEXT[ vsx,vsy ]::::::::::::::::::::://     // [791]
                                                                 // [791]
            //:#_100_SUPER_SAMPLE_SLOW_RUN_#:[791]:------://

                    a_r =( a_r / swa );
                    a_g =( a_g / swa );
                    a_b =( a_b / swa );
                    a_a =( a_a / swa );

            //:------:#_100_SUPER_SAMPLE_SLOW_RUN_#:[791]://
            //:#_CAP_AND_CREATE_BYTE_VALUE_#:[791]:------://     // [791]
                                                                 // [791]
                //:#_FLOOR_BEFORE_CAST_#:[791]:----------://     // [791]
                                                                 // [791]
                    a_r =( F_M_F( a_r ) );                       // [791]
                    a_g =( F_M_F( a_g ) );                       // [791]
                    a_b =( F_M_F( a_b ) );                       // [791]
                    a_a =( F_M_F( a_a ) );                       // [791]
                                                                 // [791]
                //:----------:#_FLOOR_BEFORE_CAST_#:[791]://     // [791]
                //:#_CAP_BEFORE_CAST_#:[791]:------------://     // [791]
                                                                 // [791]
                    if( a_r < 0x0 ){ a_r = 0x0 ; };              // [791]
                    if( a_g < 0x0 ){ a_g = 0x0 ; };              // [791]
                    if( a_b < 0x0 ){ a_b = 0x0 ; };              // [791]
                    if( a_a < 0x0 ){ a_a = 0x0 ; };              // [791]
                                                                 // [791]
                    if( a_r > 255 ){ a_r = 255 ; };              // [791]
                    if( a_g > 255 ){ a_g = 255 ; };              // [791]
                    if( a_b > 255 ){ a_b = 255 ; };              // [791]
                    if( a_a > 255 ){ a_a = 255 ; };              // [791]
                                                                 // [791]
                //:------------:#_CAP_BEFORE_CAST_#:[791]://     // [791]
                //:#_CAST_TO_BYTE_#:[791]:---------------://     // [791]
                                                                 // [791]
                    b_r =( a_r );                                // [791]
                    b_g =( a_r );                                // [791]
                    b_b =( a_r );                                // [791]
                    b_a =( a_r );                                // [791]
                                                                 // [791]
                //:---------------:#_CAST_TO_BYTE_#:[791]://     // [791]
                                                                 // [791]
            //:------:#_CAP_AND_CREATE_BYTE_VALUE_#:[791]://     // [791]
            //:#_AVERAGE_PIXEL_INSERT_#:[791]:-----------://     // [791]
                                                                 // [791]
                lii =( lix + ( liy * l_w ) );                    // [791]
                lic =( lii * 4 );;;;;;;;;;;;;                    // [791]
                                                                 // [791]
                p_l[ lic+0 ]=( b_r );                            // [791]
                p_l[ lic+1 ]=( b_g );                            // [791]
                p_l[ lic+2 ]=( b_b );                            // [791]
                p_l[ lic+3 ]=( b_a );                            // [791]
                                                                 // [791]
            //:-----------:#_AVERAGE_PIXEL_INSERT_#:[791]://     // [791]
                                                                 // [791]
        };;};; //:NEXT[ lix,liy ]:::::::::::::::::::[791]://     // [791]
        //:---------------------:#_DOWNSCALE_LOOP_#:[791]://     // [791]


    #_DOWNSCALE_LOOP_# :--------------------------------------+  // [791]
                                                              |  // [791]
        Loop through each pixel of smaller destination        |  // [791]
        image and compute the average color of the pixel      |  // [791]
        it maps to within the bigger source image.            |  // [791]
                                                              |  // [791]
    :--------------------------------------: #_DOWNSCALE_LOOP_#  // [791]
                                                                 // [791]
    #_100_SUPER_SAMPLE_SLOW_RUN_# :---------------------------+  // [791]
                                                              |  // [791]
        @100_SUPER_SAMPLE_SLOW_RUN@ :----------------------+  |  // [791]
                                                           |  |  // [791]
            100% Super Sampling Slow Run.                  |  |  // [791]
            As apposed to 100% super sampling speed run.   |  |  // [791]
            Which isn't possible because this is a         |  |  // [791]
            CPU_EXPENSIVE thing to be doing.               |  |  // [791]
                                                           |  |  // [791]
        :----------------------: @100_SUPER_SAMPLE_SLOW_RUN@  |  // [791]
                                                              |  // [791]
        We need to take the accumulated[ R,G,B,A ]totals      |  // [791]
        and divide them by the total number of pixels         |  // [791]
        within our[ sample_window ]that is over the           |  // [791]
        [ bigger_selection_area ]to create a[ 1_PIXEL ]       |  // [791]
        representation of that area that can go into          |  // [791]
        our downscaled bitmap.                                |  // [791]
                                                              |  // [791]
        Mip Maps are just super sampling at max quality.      |  // [791]
        So... Mip maps are just super sampling with           |  // [791]
        zero skipped steps... So... Mip maps are just         |  // [791]
        super sampling with extra steps? All the extra        |  // [791]
        steps? What does Rich Sanchez think about that?       |  // [791]
                                                              |  // [791]
    :---------------------------: #_100_SUPER_SAMPLE_SLOW_RUN_#  // [791]
    #_CAP_AND_CREATE_BYTE_VALUE_# :---------------------------+  // [791]
                                                              |  // [791]
        Cast the floating point byte value to an actual       |  // [791]
        byte value. ( Well, if this is C99 code ).            |  // [791]
        And the make sure the byte is in the correct range.   |  // [791]
                                                              |  // [791]
        #_FLOOR_BEFORE_CAST_# :----------------------------+  |  // [791]
                                                           |  |  // [791]
            Turn the average value into an integer by      |  |  // [791]
            chopping off the [ decimal / float ] part      |  |  // [791]
            of the number. Use Functiom_Math_Floor(F_M_F)  |  |  // [791]
            to achieve this.                               |  |  // [791]
                                                           |  |  // [791]
        :----------------------------: #_FLOOR_BEFORE_CAST_#  |  // [791]
        #_CAP_BEFORE_CAST_# :------------------------------+  |  // [791]
                                                           |  |  // [791]
            Before downcasting to byte, we need to make    |  |  // [791]
            sure the 32-bit number is within the valid     |  |  // [791]
            [ 0 - 255 ]value range of a byte.              |  |  // [791]
                                                           |  |  // [791]
            Use value capping code here to make that       |  |  // [791]
            a reality.                                     |  |  // [791]
                                                           |  |  // [791]
        :------------------------------: #_CAP_BEFORE_CAST_#  |  // [791]
        #_CAST_TO_BYTE_# :---------------------------------+  |  // [791]
                                                           |  |  // [791]
            Downcast the[ in_byte_range ]value             |  |  // [791]
            to a[ byte ]that can be put into               |  |  // [791]
            our[ RGBA ]pixel array. (4BytePerPixelArray)   |  |  // [791]
                                                           |  |  // [791]
        :---------------------------------: #_CAST_TO_BYTE_#  |  // [791]
                                                              |  // [791]
    :---------------------------: #_CAP_AND_CREATE_BYTE_VALUE_#  // [791]
    #_AVERAGE_PIXEL_INSERT_# :--------------------------------+  // [791]
                                                              |  // [791]
        Insert average color into the target bitmap.          |  // [791]
                                                              |  // [791]
    :--------------------------------: #_AVERAGE_PIXEL_INSERT_#  // [791]